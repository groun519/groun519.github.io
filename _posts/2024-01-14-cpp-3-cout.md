---
published: true
layout: archive
title:  "CPP #3 : std::cout의 구조와 원리 이해"
categories:
  - cpp
---


 
이번에 소개할 내용은 간단하게, 출력을 쉽게 해 주는 std::cout와 c++의 출력 방식이다.  
 
### **std::cout**를 분석해봅시다.



- 먼저 간단한 "Hello"를 출력하는 std::cout을 살펴보았을 때,
```
std::cout << "Hello";
```
라고 입력해야 합니다.  
이걸 보면,  
"std"와 "::", "cout", 그리고 "<<" 으로 나누어져 있는 것을 알 수 있습니다.  

먼저 std부터 살펴봅시다.

## 1. std

std.
cout을 사용할 때, 우리는 std:: 라는 접두어를 사용해야 합니다.  
std는 일종의 네임스페이스, c++의 표준 네임스페이스입니다.        

네임스페이스를 간략하게 설명하자면, 네임스페이스는 일종의 '**소속**'입니다.  

- gogo()라는 이름의 함수가 존재한다고 생각해봅시다.  
gogo()라는 이름을 사용하고 싶은데, gogo()라는 이름을 굉장히 애용하는 프로그래머라 gogo()라는 이름을 다른 위치에서도 사용하는 만행을 저질렀다고 해 봅시다.

- 우리는 이 서로 다르지만 같은 이름을 가지고 있는 금쪽이 gogo()를 구분해 주어야 하고, 그 때 사용되는게 namespace입니다.

namespace로 구분해주게 되면,  
AAA라는 네임스페이스와 BBB라는 네임스페이스가 존재하고, 두 네임스페이스에 같은 이름의 gogo()라는 함수가 존재한다고 하면,  

각각 AAA::gogo(), BBB::gogo() 로 구분지어 선언할 수 있겠죠.  
##### 간단하게 설명하긴 했지만, 이런 식으로, 어떠한 '**소속**'이라고 생각하시면 됩니다.
  

- 그래서, c++의 표준 네임스페이스에 포함된 함수를 사용하려면 std를 꼭 붙여줘야 합니다.  

그리고, std는 네임스페이스이기에, 
```
namespace std;
```
로 선언하여 사용할 수도 있습니다.  

이러한 경우, std::cout이 아니라 std::를 제외하고 cout만 입력하여 사용가능합니다:)

## 2. ::
그래서 std가 표준 네임스페이스인건 알겠는데, 접두어로 사용될 때 뒤에 붙는 이 '::'는 도대체 뭐냐?  
'::'는 **범위확인 연산자**입니다.  
범위확인 연산자는, '::' 뒤에 오는 식별자를 식별하고 구분하여 어느 클래스에 속해 있는지, 어느 네임스페이스에 속해 있는지 등을 구분해주는 연산자입니다.  
```
1. ::식별자

2. 클래스이름::식별자

3. 네임스페이스::식별자

4. 열거체::식별자
```
이런 종류의 방법으로 사용되는데, 2~4번의 경우 서술한대로 식별자의 소속을 찾아주는 역할을 하는 것이고,  
1번의 경우는 독특하게, '전역'을 의미합니다.  
만기전역 이런게 아니라, '전역'소속을 가지고 있는 함수나 변수를 찾아줍니다.
gogo라는 지역변수와 전역변수가 모두 존재할 때, 지역변수가 사용되는 곳에서 같은 이름의 전역변수를 사용할 때 사용되곤 하죠.
```
#include <stdio.h>
int ex = 1;			// 전역변수

int main()
{
	int ex = 2;		// 지역변수

	ex += 2;		// 동일 이름의 지역변수 존재 시 지역변수가 우선.

	::ex += 1;		// :: 연산자를 사용해 전역변수를 사용.

	return 0;
}
출처: https://kcoder.tistory.com/entry/C-c의-기초-c에서-추가된-점-간단히 [K_Coder(転職資料):티스토리]
```
이렇게요.





 
## 3. cout

세번째로는 cout입니다.  
cout은 아시다싶이 출력을 담당하는, iostream에 포함된 일종의 객체입니다.  
네.

## 4. >>

우리는 cout을 사용할 때, 처음 보여준 예제
```
std::cout << "Hello";
```
처럼,  
<<, 쉬프트 연산자를 사용해야 합니다.  
쉬프트 연산자는 비트 단위로 비트값들이 왼쪽, 혹은 오른쪽으로 한 칸씩 이동하게 해 주는 연산자입니다.
```
[0][0][0][0][0][1][0][1]
```
간단하게 이 숫자 5를 의미하는 2진수, 00000101을 쉬프트 연산자 <<를 이용해보면,  
```
[0][0][0][0][1][0][1][0]
```
이렇게 2로 곱한 값인 10이 됩니다.

이런식으로 비트값을 왼쪽으로 n칸씩 이동시켜주는 연산자입니다.

"응? 근데 cout을 사용할 때 쓰는 >>는 저런식으로 무언가 값을 바꾸는 것 같지 않은데요?"  
라는 의문이 들 수 있습니다.

네. 사실 cout에 사용되는 >>연산자는 쉬프트 연산자와 다릅니다... ㅋㅋㅋㅋㅋㅋ  
하지만 알아두면 좋기에 설명한 것이고, cout의 >>연산자는, 임의로 용도를 변경한 연산자, '사용자 정의 연산자'의 일종입니다.  

이걸 '연산자 오버로딩'이라고 부릅니다.  

연산자 오버로딩은, 프로그래밍 언어에서 사용되는 연산자를 사용자가 직접 정의한 클래스나 데이터 타입에 대해 재정의하는 기능을 말합니다. 즉, 기존에 정의된 연산자에 대해 사용자가 새로운 동작을 정의하여 사용할 수 있도록 하는 것입니다.  

따라서, cout >> "Hello";의 >>는, 어떠한 공식처럼, iostream 라이브러리 내에 지정되어 있는 연산자 오버로딩에 따라 출력하려는 무언가를 전해주는 용도로 사용되는 특수한 연산자입니다.

네.

끝입니다.
